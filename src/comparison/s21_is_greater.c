#include "./../s21_decimal.h"

// Функция для проверки, является ли value_1 больше value_2
int s21_is_greater(s21_decimal value_1, s21_decimal value_2) {
    // Если оба значения равны нулю, они не могут быть больше друг друга, поэтому возвращаем 0 (ложь)
    if (isNull(value_1) && isNull(value_2)) {
        return 0; // Числа равны (оба нули), возвращаем ложь
    }

    // Получаем знаки обоих значений: 0 для положительного числа, 1 для отрицательного
    int sign_a = getSign(value_1); // Определяем знак value_1
    int sign_b = getSign(value_2); // Определяем знак value_2

    // Если знаки разные, число с положительным знаком всегда больше
    if (sign_a != sign_b) {
        return (sign_a == 0); // Возвращаем 1 (истина), если первое число положительное
    }

    // Выравниваем масштаб значений (scale) для корректного сравнения
    alignmentScale(&value_1, &value_2); // Приводим оба числа к одинаковому масштабу для корректного сравнения

    // Сравниваем числа побитово, начиная с высших битов (от 95-го бита к 0-му)
    for (int i = 95; i >= 0; i--) {
        int bit_a = getBit(value_1, i); // Получаем значение бита на позиции i для value_1
        int bit_b = getBit(value_2, i); // Получаем значение бита на позиции i для value_2
        
        // Если биты на текущей позиции не равны
        if (bit_a != bit_b) {
            // Определяем результат в зависимости от знака чисел
            // Если первый бит больше и число положительное, возвращаем истину (1)
            // Если число отрицательное и первый бит больше, возвращаем ложь (0)
            return (bit_a > bit_b) ? (sign_a == 0) : (sign_a != 0);
        }
    }

    // Если все биты равны, то оба числа равны, и первое число не больше второго
    return 0; // Числа равны, возвращаем ложь (0)
}